---
title: "Selection_analyses_somaticIBD"
author: "Sigurgeir Olafsson"
date: "3/9/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Selection analyses for the paper 'Somatic evolution in the non-neoplastic IBD affected colon'

Here I document how to reproduce the selection analyses of the manuscript. 

```{r}
crypt_meta <- read.table("/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table2_crypt_metaData.txt", h=T)

ibd_full <- read.table("/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Mendeley_data/All_IBD_cohort_mutations_mapped_to_branches.txt", h=T, stringsAsFactors = F)
control_full <- read.table("/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Mendeley_data/All_control_cohort_mutations_mapped_to_branches.txt", h=T, stringsAsFactors = F)

hotspots <- read.table("/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table7_TCGA_canonical_hotspots.txt", h=T)

```


## Gene-level selection analysis

```{r}
library("seqinr")
library("Biostrings")
library("MASS")
library("GenomicRanges")
library("dndscv")

dndsout_ibd <- dndscv(ibd_full)
dndsout_ctrl <- dndscv(control_full)

sel_cv = dndsout_ibd$sel_cv
signif_genes_ibd = sel_cv[sel_cv$qglobal_cv<0.1, ]

## Note: This is not the complete control dataset from Lee-Six et al. That paper also includes some
## targeted sequencing data which is not included here. AXIN2 and STAG2 are not picked up in this smaller dataset. 
sel_cv_ctrl = dndsout_ctrl$sel_cv
signif_genes_ctrl = sel_cv_ctrl[sel_cv_ctrl$qglobal_cv<0.1, ]

ibd_coding <- dndsout_ibd$annotmuts
control_coding <- dndsout_ctrl$annotmuts

write.table(ibd_coding, "/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table4a_coding_subs_and_indels_IBD.txt", row.names=F, quote=F, sep="\t")
write.table(control_coding, "/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table4b_coding_subs_and_indels_controls.txt", row.names=F, quote=F, sep="\t")
write.table(sel_cv, "/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table10_gene_level_dNdS.txt", row.names = F, quote = F, sep="\t")

signif_genes_ibd
```


## Compose a list of drivers

Read in a list of colorectal cancer genes. This list can be found in Supplementary Table 12. 

Define putative drivers as mutations falling into any of these three classes: \\
1. Mutations overlapping known canonical cancer hotspots.\\
2. Loss-of-function mutations in known colorectal tumor suppressors. \\
3. Truncating mutations in AXIN2 or STAG2, which are under positive selection in the normal colon in Lee Six et al (2019). () \\
4. Mutations in genes that we find to be under positive selection in IBD (except only include truncating mutations in ARID1A and PIGR). \\
5. Mutations in genes that are not in the lists above but are reported in Nanki et al and Kakiuchi et al. \\


Note: In the driver section of the manuscript, I present results from regressing the number of driver mutations against the mutation burden of the crypts. This analysis only uses the drivers in 1-3 above, not the "IBD drivers".

```{r}
colorectal_cancer_genes <- read.table("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/colorectal_cancer_gene_list.txt", stringsAsFactors = F)
Lof_genes <- c(colorectal_cancer_genes$V1, "AXIN2", "STAG2")

# Genes reported in Nanki et al and Kakiuchi et al. 
# Which we replicate at q<0.1 (see Restricted hypothesis testing below)
prior_genes <- c("NFKBIZ",  "NOS2", "IL17RA", "HNRNPF", "BCOR","ETV6")

positively_selected_genes <- c(as.character(signif_genes_ibd$gene_name), prior_genes)


## Look for mutations in both datasets that are found in driver hotspots, even in genes that
## are not significant in the gene-based analysis
hotspots$ID <- paste(hotspots$chr, hotspots$pos, hotspots$ref, hotspots$mut, sep="_")

ibd_coding$ID <- paste(ibd_coding$chr, ibd_coding$pos, ibd_coding$ref, ibd_coding$mut, sep="_")
ibd_hotspots <- ibd_coding[ibd_coding$ID %in% hotspots$ID, ]

control_coding$ID <- paste(control_coding$chr, control_coding$pos, control_coding$ref, control_coding$mut, sep="_")
control_hotspots <- control_coding[control_coding$ID %in% hotspots$ID, ]

ibd_lof <- ibd_coding[ibd_coding$gene %in% Lof_genes & ibd_coding$impact!="Synonymous" & ibd_coding$impact!="Missense",]

control_lof <- control_coding[control_coding$gene %in% Lof_genes & control_coding$impact!="Synonymous" & control_coding$impact!="Missense",]

ibd_pos_sel <- ibd_coding[ibd_coding$gene %in% positively_selected_genes,]
control_pos_sel <- control_coding[control_coding$gene %in% positively_selected_genes,]

ibd_hotspots$cohort <- "IBD"
ibd_lof$cohort <- "IBD"
ibd_pos_sel$cohort <- "IBD"
control_hotspots$cohort <- "CTRL"
control_lof$cohort <- "CTRL"
control_pos_sel$cohort <- "CTRL"

putative_drivers <- rbind(ibd_hotspots, ibd_lof, ibd_pos_sel, control_hotspots, control_lof, control_pos_sel)

putative_drivers <- putative_drivers[!(putative_drivers$gene %in% c("ARID1A", "PIGR") & putative_drivers$impact=="Missense"),]
putative_drivers <- putative_drivers[putative_drivers$impact!="Synonymous",]

putative_drivers$driver_type <- "LoF_Tumor_suppressor"
putative_drivers$driver_type[putative_drivers$impact=="Missense"] <- "Canonical_hotspot"
putative_drivers$driver_type[putative_drivers$gene %in% c("PIGR", "ZC3H12A", "ARID1A", "FBXW7")] <- "Positiverly_selected_mutation"

putative_drivers <- putative_drivers[!duplicated(putative_drivers),]

write.table(putative_drivers, "/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table8_Driver_candidates.txt", quote = F, row.names = F, sep="\t")

table(putative_drivers$cohort)
```


## Comparing genes under selection in IBD and normal colon

This is the data which is presented in Supplementary Table 10. 

```{r}
positively_selected_genes_ctrl <- c("AXIN2", "STAG2")

ibd_healthy_colon <- sel_cv[sel_cv$gene_name %in% positively_selected_genes_ctrl, ]

ibd_healthy_colon

ctrl_ibd <- sel_cv_ctrl[sel_cv_ctrl$gene_name %in% positively_selected_genes, ]

ctrl_ibd
```

## Comparison of positive selection between UC and CD

First I want to assign mutations to diseases.

```{r}
ibd_full$Patient_ID <- unlist(strsplit(as.character(ibd_full$SampleID), "_"))[c(T,F)]

muts_UC <- subset(ibd_full, Patient_ID %in% crypt_meta$patient_ID[crypt_meta$Disease=="UC"])
dndsout_UC <- dndscv(muts_UC)
sel_cv_UC = dndsout_UC$sel_cv
signif_genes_UC = sel_cv_UC[sel_cv_UC$qallsubs_cv<0.1, ]

muts_CD <- subset(ibd_full, Patient_ID %in% crypt_meta$patient_ID[crypt_meta$Disease=="CD"])
dndsout_CD <- dndscv(muts_CD)
sel_cv_CD = dndsout_CD$sel_cv
signif_genes_CD = sel_cv_CD[sel_cv_CD$qallsubs_cv<0.1, ]
```

I next create a function to test for differences between two cohorts. It should be noted though, that this analysis is not particularly powerful, and less powerful than comparing one dataset with the expected distribution. 

```{r}

## To estimate the expected number of indels, we use genes that should not be under positive selection. 
#divide genes into potential drivers and passengers as per list attached to dNdS package
data(list = "cancergenes_cgc81", package = "dndscv")
passenger=setdiff(dndsout_ibd$genemuts$gene_name,known_cancergenes) 
IL17_genes <- read.table("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/IL17_reactome.txt", sep="", stringsAsFactors = F)
TLR_genes <- read.table("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/TLR_reactome.txt", sep="", stringsAsFactors = F)
any_cancer_genes <- read.table("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/pan_cancer_analysis.txt", sep="", stringsAsFactors = F)

## Remove from the 'passenger' gene lists those genes which may be under positive selection in the 
## normal or IBD colon. Estimate the indel mutation rate from the rest. 
excl_genes <- c(c("AXIN2", "STAG2", "PIK3CA", "ERBB2", "ERBB3","FBXW7", "PIGR", "ARID1A", "ZC3H12A",
                  "NFKBIZ", "TRAF3IP2", "HNRNPF", "IL17RA", "IL17RC", "RELA", "MAPK14", "BTRC", "TRAF5", 
                  "ARID1B", "BCORL1", "BCOR", "ETV6", "RNF43"), IL17_genes$V1, TLR_genes$V1, any_cancer_genes$V1)

passenger <- passenger[!(passenger %in% excl_genes)]


## This function compares dNdS ratios from two dndscv objects using a poisson test. 
## Takes two dndscv objects calculated on different cohorts as input, as well as a list of genes
## we expect mostly not to be under positive selection (i.e all genes excluding only those which we think
## might be under positive selection)
compare_dnds <- function(dndscv_x, dndscv_y, expected_neutral_genes=passenger) {
  
  ## To compare the two datasets, we need the observed and expected number of mutations in each class in each 
  ## cohort. dNdScv outputs these values for the subs but not for the indels. 
  types=c("mis","non","spl","ind")
  
  #Get info from dNdS outputs
  counts_x=dndscv_x$sel_cv[,c("gene_name","n_syn","n_mis","n_non","n_spl","n_ind")]
  counts_x <- counts_x[order(counts_x$gene_name),]
  counts_y=dndscv_y$sel_cv[,c("gene_name","n_syn","n_mis","n_non","n_spl","n_ind")]
  counts_y <- counts_y[order(counts_y$gene_name),]
  
  ## Get the correction factor from the model
  r_x = dndscv_x$genemuts$exp_syn_cv / dndscv_x$genemuts$exp_syn
  r_y = dndscv_y$genemuts$exp_syn_cv / dndscv_y$genemuts$exp_syn
  #r=1 if no correction for covariates
  
  
  correction_x=colSums(dndscv_x$genemuts[dndscv_x$genemuts$gene_name%in%passenger,c("n_syn","n_mis","n_non","n_spl")])/
    colSums(dndscv_x$genemuts[dndscv_x$genemuts$gene_name%in%passenger,c("exp_syn","exp_mis","exp_non","exp_spl")]) #instead of globaldnds values
  
  counts_x[,c("exp_syn","exp_mis","exp_non","exp_spl")]=t(t(dndscv_x$genemuts[,c("exp_syn","exp_mis","exp_non","exp_spl")])*correction_x)*r_x

  correction_y=colSums(dndscv_y$genemuts[dndscv_y$genemuts$gene_name%in%passenger,c("n_syn","n_mis","n_non","n_spl")])/
    colSums(dndscv_y$genemuts[dndscv_y$genemuts$gene_name%in%passenger,c("exp_syn","exp_mis","exp_non","exp_spl")]) #instead of globaldnds values
  
  counts_y[,c("exp_syn","exp_mis","exp_non","exp_spl")]=t(t(dndscv_y$genemuts[,c("exp_syn","exp_mis","exp_non","exp_spl")])*correction_y)*r_y
  
  
  passenger_length=sum(unlist(lapply(RefCDS,function(x) ifelse(x$gene_name%in%expected_neutral_genes,x$CDS_length,0))))
  passenger_indels_x=sum(dndscv_x$sel_cv$n_ind[dndscv_x$sel_cv$gene_name%in%expected_neutral_genes])
  indel_rate_x=passenger_indels_x/passenger_length #Estimate mutationrate of indels

  passenger_indels_y=sum(dndscv_y$sel_cv$n_ind[dndscv_y$sel_cv$gene_name%in%expected_neutral_genes])
  indel_rate_y=passenger_indels_y/passenger_length #Estimate mutationrate of indels
  
  counts_x$exp_ind=unlist(lapply(1:nrow(counts_x), function(x) indel_rate_x*RefCDS[[x]]$CDS_length)) #expected number of indels is indel rate times length of cds
  counts_y$exp_ind=unlist(lapply(1:nrow(counts_y), function(x) indel_rate_y*RefCDS[[x]]$CDS_length)) #expected number of indels is indel rate times length of cds
  
  missense = data.frame(counts_x$n_mis, counts_y$n_mis, counts_x$exp_mis, counts_y$exp_mis)
  missense$pval=apply(missense, 1, function(x) poisson.test(x=c(x[1],x[2]), T=c(x[3],x[4]))$p.value)
  
  # Combine truncating and splicing variants into one.
  truncating = data.frame(counts_x$n_non+counts_x$n_spl, counts_y$n_non+counts_y$n_spl, counts_x$exp_non+counts_x$exp_spl+0.00001, counts_y$exp_non+counts_y$exp_spl+0.00001)
  truncating$pval=apply(truncating, 1, function(x) poisson.test(x=c(x[1],x[2]), T=c(x[3],x[4]))$p.value)
  
  indels = data.frame(counts_x$n_ind, counts_y$n_ind, counts_x$exp_ind, counts_y$exp_ind)
  indels$pval=apply(indels, 1, function(x) poisson.test(x=c(x[1],x[2]), T=c(x[3],x[4]))$p.value)
  
  results <- cbind(missense, truncating, indels)
  results$gene_name <- counts_x$gene_name
  results <- results[, c(16, 1,2,5,6,7,10,11,12,15)]
  colnames(results) <- c("gene_name", "Missense_x", "Missense_y", "Missense_P", "Truncating_x", "Truncating_y", "Truncating_P", "Indel_x",
                         "Indel_y", "Indel_P")
  
  results$Missense_q = p.adjust(results$Missense_P, method="BH")
  results$Truncating_q = p.adjust(results$Truncating_P, method="BH")
  results$Indel_q = p.adjust(results$Indel_P, method="BH")
  
  # Fisher combined p-values (substitutions and indels)
  results$P_combined = 1 - pchisq(-2 * (log(results$Missense_P) + log(results$Truncating_P) + log(results$Indel_P)), df = 6)
  results$q_combined = p.adjust(results$P_combined, method="BH")
  
  results <- results[, c(1:4,11,5:7,12,8:10,13:15)]
  
  return(results)
  
}


## Positive control: Check for difference between colon and breast
data("dataset_simbreast", package="dndscv")
dndsout_breast = dndscv(mutations)
test <- compare_dnds(dndsout_breast, dndsout_ctrl,expected_neutral_genes = passenger)
head(test[order(test$q_combined),])
## Note: Looks like the power isn't great. Very few differences detected. 

cd_vs_uc <- compare_dnds(dndsout_CD, dndsout_UC, expected_neutral_genes = passenger)
ibd_vs_ctrl <- compare_dnds(dndsout_ibd, dndsout_ctrl, expected_neutral_genes = passenger)

head(cd_vs_uc[order(cd_vs_uc$q_combined),])
head(ibd_vs_ctrl[order(ibd_vs_ctrl$q_combined),])
```



## Pathway level selection analysis

We defined a list of gene-sets a priori. We used genes associated with colorectal cancer and significant in a pan-cancer analysis in Priestley, P. et al. (2019, Nature). \\
We next chose a set of pathways important in IBD pathogenesis. We used Reactome.org to define the pathways.\\

The gene lists can be found in Supplementary Table12. 

```{r, echo=FALSE}
## Load a little hack to the dnds function to output P-values for wtrunc
## This will define the function dndscv_pvalspois()
# source("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/dndscv_pvalspois.R")


dndscv_pvalspois = function(mutations, gene_list = NULL, refdb = "hg19", sm = "192r_3w", kc = "cgc81", cv = "hg19", max_muts_per_gene_per_sample = 3, max_coding_muts_per_sample = 3000, use_indel_sites = T, min_indels = 5, maxcovs = 20, constrain_wnon_wspl = T, outp = 3, numcode = 1, outmats = F) {

    ## 1. Environment
    message("[1] Loading the environment...")

    mutations = mutations[,1:5] # Restricting input matrix to first 5 columns
    mutations[,c(1,2,3,4,5)] = lapply(mutations[,c(1,2,3,4,5)], as.character) # Factors to character
    mutations[[3]] = as.numeric(mutations[[3]]) # Chromosome position as numeric
    mutations = mutations[mutations[,4]!=mutations[,5],] # Removing mutations with identical reference and mutant base
    colnames(mutations) = c("sampleID","chr","pos","ref","mut")
    
    # Removing NA entries from the input mutation table
    indna = which(is.na(mutations),arr.ind=T)
    if (nrow(indna)>0) {
        mutations = mutations[-unique(indna[,1]),] # Removing entries with an NA in any row
        warning(sprintf("%0.0f rows in the input table contained NA entries and have been removed. Please investigate.",length(unique(indna[,1]))))
    }
    
    # [Input] Reference database
    if (refdb == "hg19") {
        data("refcds_hg19", package="dndscv")
        if (FALSE) { # Replace CDKN2A in the input gene list with two isoforms
            gene_list = unique(c(setdiff(gene_list,"CDKN2A"),"CDKN2A.p14arf","CDKN2A.p16INK4a"))
        }
    } else {
        load(refdb)
    }
    
    # [Input] Gene list (The user can input a gene list as a character vector)
    if (is.null(gene_list)) {
        gene_list = sapply(RefCDS, function(x) x$gene_name) # All genes [default]
    } else { # Using only genes in the input gene list
        allg = sapply(RefCDS,function(x) x$gene_name)
        nonex = gene_list[!(gene_list %in% allg)]
        if (length(nonex)>0) { stop(sprintf("The following input gene names are not in the RefCDS database: %s", paste(nonex,collapse=", "))) }
        RefCDS = RefCDS[allg %in% gene_list] # Only input genes
        gr_genes = gr_genes[gr_genes$names %in% gene_list] # Only input genes
    }

    # [Input] Covariates (The user can input a custom set of covariates as a matrix)
    if (is.character(cv)) {
        data(list=sprintf("covariates_%s",cv), package="dndscv")
    } else {
        covs = cv
    }
    
    # [Input] Known cancer genes (The user can input a gene list as a character vector)
    if (kc[1] %in% c("cgc81")) {
        data(list=sprintf("cancergenes_%s",kc), package="dndscv")
    } else {
        known_cancergenes = kc
    }
    
    # [Input] Substitution model (The user can also input a custom substitution model as a matrix)
    if (length(sm)==1) {
        data(list=sprintf("submod_%s",sm), package="dndscv")
    } else {
        substmodel = sm
    }
    
    # Expanding the reference sequences [for faster access]
    for (j in 1:length(RefCDS)) {
        RefCDS[[j]]$seq_cds = base::strsplit(as.character(RefCDS[[j]]$seq_cds), split="")[[1]]
        RefCDS[[j]]$seq_cds1up = base::strsplit(as.character(RefCDS[[j]]$seq_cds1up), split="")[[1]]
        RefCDS[[j]]$seq_cds1down = base::strsplit(as.character(RefCDS[[j]]$seq_cds1down), split="")[[1]]
        if (!is.null(RefCDS[[j]]$seq_splice)) {
            RefCDS[[j]]$seq_splice = base::strsplit(as.character(RefCDS[[j]]$seq_splice), split="")[[1]]
            RefCDS[[j]]$seq_splice1up = base::strsplit(as.character(RefCDS[[j]]$seq_splice1up), split="")[[1]]
            RefCDS[[j]]$seq_splice1down = base::strsplit(as.character(RefCDS[[j]]$seq_splice1down), split="")[[1]]
        }
    }
    
    
    ## 2. Mutation annotation
    message("[2] Annotating the mutations...")
    
    nt = c("A","C","G","T")
    trinucs = paste(rep(nt,each=16,times=1),rep(nt,each=4,times=4),rep(nt,each=1,times=16), sep="")
    trinucinds = setNames(1:64, trinucs)
    trinucsubs = NULL
    for (j in 1:length(trinucs)) {
        trinucsubs = c(trinucsubs, paste(trinucs[j], paste(substr(trinucs[j],1,1), setdiff(nt,substr(trinucs[j],2,2)), substr(trinucs[j],3,3), sep=""), sep=">"))
    }
    trinucsubsind = setNames(1:192, trinucsubs)
    
    ind = setNames(1:length(RefCDS), sapply(RefCDS,function(x) x$gene_name))
    gr_genes_ind = ind[gr_genes$names]
    
    # Warning about possible unannotated dinucleotide substitutions
    if (any(diff(mutations$pos)==1)) {
        warning("Mutations observed in contiguous sites within a sample. Please annotate or remove dinucleotide or complex substitutions for best results.")
    }
    
    # Warning about multiple instances of the same mutation in different sampleIDs
    if (nrow(unique(mutations[,2:5])) < nrow(mutations)) {
        warning("Same mutations observed in different sampleIDs. Please verify that these are independent events and remove duplicates otherwise.")
    }
    
    # Start and end position of each mutation
    mutations$end = mutations$start = mutations$pos
    l = nchar(mutations$ref)-1 # Deletions of multiple bases
    mutations$end = mutations$end + l
    ind = substr(mutations$ref,1,1)==substr(mutations$mut,1,1) & nchar(mutations$ref)>nchar(mutations$mut) # Position correction for deletions annotated in the previous base (e.g. CA>C)
    mutations$start = mutations$start + ind
    
    # Mapping mutations to genes
    gr_muts = GenomicRanges::GRanges(mutations$chr, IRanges::IRanges(mutations$start,mutations$end))
    ol = as.data.frame(GenomicRanges::findOverlaps(gr_muts, gr_genes, type="any", select="all"))
    mutations = mutations[ol[,1],] # Duplicating subs if they hit more than one gene
    mutations$geneind = gr_genes_ind[ol[,2]]
    mutations$gene = sapply(RefCDS,function(x) x$gene_name)[mutations$geneind]
    mutations = unique(mutations)
    
    # Optional: Excluding samples exceeding the limit of mutations/sample [see Default parameters]
    nsampl = sort(table(mutations$sampleID))
    exclsamples = NULL
    if (any(nsampl>max_coding_muts_per_sample)) {
        message(sprintf('    Note: %0.0f samples excluded for exceeding the limit of mutations per sample (see the max_coding_muts_per_sample argument in dndscv). %0.0f samples left after filtering.',sum(nsampl>max_coding_muts_per_sample),sum(nsampl<=max_coding_muts_per_sample)))
        exclsamples = names(nsampl[nsampl>max_coding_muts_per_sample])
        mutations = mutations[!(mutations$sampleID %in% names(nsampl[nsampl>max_coding_muts_per_sample])),]
    }
    
    # Optional: Limiting the number of mutations per gene per sample (to minimise the impact of unannotated kataegis and other mutation clusters) [see Default parameters]
    mutrank = ave(mutations$pos, paste(mutations$sampleID,mutations$gene), FUN = function(x) rank(x))
    exclmuts = NULL
    if (any(mutrank>max_muts_per_gene_per_sample)) {
        message(sprintf('    Note: %0.0f mutations removed for exceeding the limit of mutations per gene per sample (see the max_muts_per_gene_per_sample argument in dndscv)',sum(mutrank>max_muts_per_gene_per_sample)))
        exclmuts = mutations[mutrank>max_muts_per_gene_per_sample,]
        mutations = mutations[mutrank<=max_muts_per_gene_per_sample,]
    }
    
    # Additional annotation of substitutions
    
    mutations$strand = sapply(RefCDS,function(x) x$strand)[mutations$geneind]
    snv = (mutations$ref %in% nt & mutations$mut %in% nt)
    if (!any(snv)) { stop("Zero coding substitutions found in this dataset. Unable to run dndscv. Common causes for this error are inputting only indels or using chromosome names different to those in the reference database (e.g. chr1 vs 1)") }
    indels = mutations[!snv,]
    mutations = mutations[snv,]
    mutations$ref_cod = mutations$ref
    mutations$mut_cod = mutations$mut
    compnt = setNames(rev(nt), nt)
    isminus = (mutations$strand==-1)
    mutations$ref_cod[isminus] = compnt[mutations$ref[isminus]]
    mutations$mut_cod[isminus] = compnt[mutations$mut[isminus]]
    
    for (j in 1:length(RefCDS)) {
        RefCDS[[j]]$N = array(0, dim=c(192,4)) # Initialising the N matrices
    }
    
    # Subfunction: obtaining the codon positions of a coding mutation given the exon intervals
    
    chr2cds = function(pos,cds_int,strand) {
        if (strand==1) {
            return(which(unlist(apply(cds_int, 1, function(x) x[1]:x[2])) %in% pos))
        } else if (strand==-1) {
            return(which(rev(unlist(apply(cds_int, 1, function(x) x[1]:x[2]))) %in% pos))
        }
    }
    
    # Annotating the functional impact of each substitution and populating the N matrices
    
    ref3_cod = mut3_cod = wrong_ref = aachange = ntchange = impact = codonsub = array(NA, nrow(mutations))
    
    for (j in 1:nrow(mutations)) {
    
        geneind = mutations$geneind[j]
        pos = mutations$pos[j]
        
        if (any(pos == RefCDS[[geneind]]$intervals_splice)) { # Essential splice-site substitution
        
            impact[j] = "Essential_Splice"; impind = 4
            pos_ind = (pos==RefCDS[[geneind]]$intervals_splice)
            cdsnt = RefCDS[[geneind]]$seq_splice[pos_ind]
            ref3_cod[j] = sprintf("%s%s%s", RefCDS[[geneind]]$seq_splice1up[pos_ind], RefCDS[[geneind]]$seq_splice[pos_ind], RefCDS[[geneind]]$seq_splice1down[pos_ind])
            mut3_cod[j] = sprintf("%s%s%s", RefCDS[[geneind]]$seq_splice1up[pos_ind], mutations$mut_cod[j], RefCDS[[geneind]]$seq_splice1down[pos_ind])
            aachange[j] = ntchange[j] = codonsub[j] = "."

        } else { # Coding substitution
        
            pos_ind = chr2cds(pos, RefCDS[[geneind]]$intervals_cds, RefCDS[[geneind]]$strand)
            cdsnt = RefCDS[[geneind]]$seq_cds[pos_ind]
            ref3_cod[j] = sprintf("%s%s%s", RefCDS[[geneind]]$seq_cds1up[pos_ind], RefCDS[[geneind]]$seq_cds[pos_ind], RefCDS[[geneind]]$seq_cds1down[pos_ind])
            mut3_cod[j] = sprintf("%s%s%s", RefCDS[[geneind]]$seq_cds1up[pos_ind], mutations$mut_cod[j], RefCDS[[geneind]]$seq_cds1down[pos_ind])
            codon_pos = c(ceiling(pos_ind/3)*3-2, ceiling(pos_ind/3)*3-1, ceiling(pos_ind/3)*3)
            old_codon = as.character(as.vector(RefCDS[[geneind]]$seq_cds[codon_pos]))
            pos_in_codon = pos_ind-(ceiling(pos_ind/3)-1)*3
            new_codon = old_codon; new_codon[pos_in_codon] = mutations$mut_cod[j]
            old_aa = seqinr::translate(old_codon, numcode = numcode)
            new_aa = seqinr::translate(new_codon, numcode = numcode)
            aachange[j] = sprintf('%s%0.0f%s',old_aa,ceiling(pos_ind/3),new_aa)
            ntchange[j] = sprintf('%s%0.0f%s',mutations$ref_cod[j],pos_ind,mutations$mut_cod[j])
            codonsub[j] = sprintf('%s>%s',paste(old_codon,collapse=""),paste(new_codon,collapse=""))
        
            # Annotating the impact of the mutation
            if (new_aa == old_aa){ 
                impact[j] = "Synonymous"; impind = 1
            } else if (new_aa == "*"){
                impact[j] = "Nonsense"; impind = 3
            } else if (old_aa != "*"){
                impact[j] = "Missense"; impind = 2
            } else if (old_aa=="*") {
                impact[j] = "Stop_loss"; impind = NA
            }
        }
        
        if (mutations$ref_cod[j] != as.character(cdsnt)) { # Incorrect base annotation in the input mutation file (the mutation will be excluded with a warning)
            wrong_ref[j] = 1
        } else if (!is.na(impind)) { # Correct base annotation in the input mutation file
            trisub = trinucsubsind[ paste(ref3_cod[j], mut3_cod[j], sep=">") ]
            RefCDS[[geneind]]$N[trisub,impind] = RefCDS[[geneind]]$N[trisub,impind] + 1 # Adding the mutation to the N matrices
        }
      
        if (round(j/1e4)==(j/1e4)) { message(sprintf('    %0.3g%% ...', round(j/nrow(mutations),2)*100)) }
    }
    
    mutations$ref3_cod = ref3_cod
    mutations$mut3_cod = mut3_cod
    mutations$aachange = aachange
    mutations$ntchange = ntchange
    mutations$codonsub = codonsub
    mutations$impact = impact
    mutations$pid = sapply(RefCDS,function(x) x$protein_id)[mutations$geneind]
    
    if (any(!is.na(wrong_ref))) {
        if (mean(!is.na(wrong_ref)) < 0.1) { # If fewer than 10% of mutations have a wrong reference base, we warn the user
            warning(sprintf('%0.0f (%0.2g%%) mutations have a wrong reference base (see the affected mutations in dndsout$wrongmuts). Please identify the causes and rerun dNdScv.', sum(!is.na(wrong_ref)), 100*mean(!is.na(wrong_ref))))
        } else { # If more than 10% of mutations have a wrong reference base, we stop the execution (likely wrong assembly or a serious problem with the data)
            stop(sprintf('%0.0f (%0.2g%%) mutations have a wrong reference base. Please confirm that you are not running data from a different assembly or species.', sum(!is.na(wrong_ref)), 100*mean(!is.na(wrong_ref))))
        }
        wrong_refbase = mutations[!is.na(wrong_ref), 1:5]
        mutations = mutations[is.na(wrong_ref),]
    }
    
    if (any(nrow(indels))) { # If there are indels we concatenate the tables of subs and indels
        indels = cbind(indels, data.frame(ref_cod=".", mut_cod=".", ref3_cod=".", mut3_cod=".", aachange=".", ntchange=".", codonsub=".", impact="no-SNV", pid=sapply(RefCDS,function(x) x$protein_id)[indels$geneind]))
        
        # Annotation of indels
        ins = nchar(gsub("-","",indels$ref))<nchar(gsub("-","",indels$mut))
        del = nchar(gsub("-","",indels$ref))>nchar(gsub("-","",indels$mut))
        multisub = nchar(gsub("-","",indels$ref))==nchar(gsub("-","",indels$mut)) # Including dinucleotides
        l = nchar(gsub("-","",indels$ref))-nchar(gsub("-","",indels$mut))
        indelstr = rep(NA,nrow(indels))
        for (j in 1:nrow(indels)) {
            geneind = indels$geneind[j]
            pos = indels$start[j]:indels$end[j]
            if (ins[j]) { pos = c(pos-1,pos) } # Adding the upstream base for insertions
            pos_ind = chr2cds(pos, RefCDS[[geneind]]$intervals_cds, RefCDS[[geneind]]$strand)
            if (length(pos_ind)>0) {
                inframe = (length(pos_ind) %% 3) == 0
                if (ins[j]) { # Insertion
                    indelstr[j] = sprintf("%0.0f-%0.0f-ins%s",min(pos_ind),max(pos_ind),c("frshift","inframe")[inframe+1])
                } else if (del[j]) { # Deletion
                    indelstr[j] = sprintf("%0.0f-%0.0f-del%s",min(pos_ind),max(pos_ind),c("frshift","inframe")[inframe+1])
                } else { # Dinucleotide and multinucleotide changes (MNVs)
                    indelstr[j] = sprintf("%0.0f-%0.0f-mnv",min(pos_ind),max(pos_ind))
                }
            }
        }
        indels$ntchange = indelstr
        annot = rbind(mutations, indels)
    } else {
        annot = mutations
    }
    annot = annot[order(annot$sampleID, annot$chr, annot$pos),]
    
    
    ## 3. Estimation of the global rate and selection parameters
    message("[3] Estimating global rates...")
    
    Lall = array(sapply(RefCDS, function(x) x$L), dim=c(192,4,length(RefCDS)))
    Nall = array(sapply(RefCDS, function(x) x$N), dim=c(192,4,length(RefCDS)))
    L = apply(Lall, c(1,2), sum)
    N = apply(Nall, c(1,2), sum)
    
    # Subfunction: fitting substitution model
    
    fit_substmodel = function(N, L, substmodel) {
    
        l = c(L); n = c(N); r = c(substmodel)
        n = n[l!=0]; r = r[l!=0]; l = l[l!=0]
        
        params = unique(base::strsplit(x=paste(r,collapse="*"), split="\\*")[[1]])
        indmat = as.data.frame(array(0, dim=c(length(r),length(params))))
        colnames(indmat) = params
        for (j in 1:length(r)) {
            indmat[j, base::strsplit(r[j], split="\\*")[[1]]] = 1
        }
        
        model = glm(formula = n ~ offset(log(l)) + . -1, data=indmat, family=poisson(link=log))
        mle = exp(coefficients(model)) # Maximum-likelihood estimates for the rate params
        ci = exp(confint.default(model)) # Wald confidence intervals
        par = data.frame(name=gsub("\`","",rownames(ci)), mle=mle[rownames(ci)], cilow=ci[,1], cihigh=ci[,2])
        return(list(par=par, model=model))
    }
    
    # Fitting all mutation rates and the 3 global selection parameters
     
    poissout = fit_substmodel(N, L, substmodel) # Original substitution model
    par = poissout$par
    poissmodel = poissout$model
    parmle =  setNames(par[,2], par[,1])
    mle_submodel = par
    rownames(mle_submodel) = NULL
    
    # Fitting models with 1 and 2 global selection parameters
    
    s1 = gsub("wmis","wall",gsub("wnon","wall",gsub("wspl","wall",substmodel)))
    par1 = fit_substmodel(N, L, s1)$par # Substitution model with 1 selection parameter
    s2 = gsub("wnon","wtru",gsub("wspl","wtru",substmodel))
    kk = fit_substmodel(N, L, s2)
    par2 = kk$par # Substitution model with 2 selection parameter
    poissmodel = kk$model
    globaldnds = rbind(par, par1, par2)[c("wmis","wnon","wspl","wtru","wall"),]
    sel_loc = sel_cv = NULL
    
    ## 4. dNdSloc: variable rate dN/dS model (gene mutation rate inferred from synonymous subs in the gene only)
    
    genemuts = data.frame(gene_name = sapply(RefCDS, function(x) x$gene_name), n_syn=NA, n_mis=NA, n_non=NA, n_spl=NA, exp_syn=NA, exp_mis=NA, exp_non=NA, exp_spl=NA, stringsAsFactors=F)
    genemuts[,2:5] = t(sapply(RefCDS, function(x) colSums(x$N)))
    mutrates = sapply(substmodel[,1], function(x) prod(parmle[base::strsplit(x,split="\\*")[[1]]])) # Expected rate per available site
    genemuts[,6:9] = t(sapply(RefCDS, function(x) colSums(x$L*mutrates)))
    numrates = length(mutrates)
    
    if (outp > 1) {
        message("[4] Running dNdSloc...")
        
        selfun_loc = function(j) {
            y = as.numeric(genemuts[j,-1])
            x = RefCDS[[j]]
            
            # a. Neutral model: wmis==1, wnon==1, wspl==1
            mrfold = sum(y[1:4])/sum(y[5:8]) # Correction factor of "t" based on the obs/exp ratio of "neutral" mutations under the model
            ll0 = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,1,1,1),dim=c(4,numrates))), log=T)) # loglik null model
            
            # b. Missense model: wmis==1, free wnon, free wspl
            mrfold = max(1e-10, sum(y[c(1,2)])/sum(y[c(5,6)])) # Correction factor of "t" based on the obs/exp ratio of "neutral" mutations under the model
            wfree = y[3:4]/y[7:8]/mrfold; wfree[y[3:4]==0] = 0
            llmis = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,1,wfree),dim=c(4,numrates))), log=T)) # loglik free wmis
            
            # c. free wmis, wnon and wspl
            mrfold = max(1e-10, y[1]/y[5]) # Correction factor of "t"
            w = y[2:4]/y[6:8]/mrfold; w[y[2:4]==0] = 0 # MLE of dN/dS based on the local rate (using syn muts as neutral)
            llall = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,w),dim=c(4,numrates))), log=T)) # loglik free wmis, wnon, wspl
            w[w>1e4] = 1e4
            
            p = 1-pchisq(2*(llall-c(llmis,ll0)),df=c(1,3))
            return(c(w,p))
        }
        
        sel_loc = as.data.frame(t(sapply(1:nrow(genemuts), selfun_loc)))
        colnames(sel_loc) = c("wmis_loc","wnon_loc","wspl_loc","pmis_loc","pall_loc")
        sel_loc$qmis_loc = p.adjust(sel_loc$pmis_loc, method="BH")
        sel_loc$qall_loc = p.adjust(sel_loc$pall_loc, method="BH")
        sel_loc = cbind(genemuts[,1:5],sel_loc)
        sel_loc = sel_loc[order(sel_loc$pall_loc,sel_loc$pmis_loc,-sel_loc$wmis_loc),]
    }
    
    
    ## 5. dNdScv: Negative binomial regression (with or without covariates) + local synonymous mutations
    
    nbreg = nbregind = NULL
    if (outp > 2) {
        
        message("[5] Running dNdScv...")
    
        # Covariates
        if (is.null(cv)) {
            nbrdf = genemuts[,c("n_syn","exp_syn")]
            model = MASS::glm.nb(n_syn ~ offset(log(exp_syn)) - 1 , data = nbrdf)
            message(sprintf("    Regression model for substitutions: no covariates were used (theta = %0.3g).", model$theta))
        } else {
            covs = covs[genemuts$gene_name,]
            if (ncol(covs) > maxcovs) {
                warning(sprintf("More than %s input covariates. Only the first %s will be considered.", maxcovs, maxcovs))
                covs = covs[,1:maxcovs]
            }
            nbrdf = cbind(genemuts[,c("n_syn","exp_syn")], covs)
            
            # Negative binomial regression for substitutions
            if (nrow(genemuts)<500) { # If there are <500 genes, we run the regression without covariates
                model = MASS::glm.nb(n_syn ~ offset(log(exp_syn)) - 1 , data = nbrdf)
            } else {
                model = tryCatch({
                    MASS::glm.nb(n_syn ~ offset(log(exp_syn)) + . , data = nbrdf) # We try running the model with covariates
                }, warning = function(w){
                    MASS::glm.nb(n_syn ~ offset(log(exp_syn)) - 1 , data = nbrdf) # If there are warnings or errors we run the model without covariates
                }, error = function(e){
                    MASS::glm.nb(n_syn ~ offset(log(exp_syn)) - 1 , data = nbrdf) # If there are warnings or errors we run the model without covariates
                })
            }
            message(sprintf("    Regression model for substitutions (theta = %0.3g).", model$theta))
        }
        if (all(model$y==genemuts$n_syn)) {
            genemuts$exp_syn_cv = model$fitted.values
        }
        theta = model$theta
        nbreg = model
        
        # Subfunction: Analytical opt_t using only neutral subs
        mle_tcv = function(n_neutral, exp_rel_neutral, shape, scale) {
            tml = (n_neutral+shape-1)/(exp_rel_neutral+(1/scale))
            if (shape<=1) { # i.e. when theta<=1
                tml = max(shape*scale,tml) # i.e. tml is bounded to the mean of the gamma (i.e. y[9]) when theta<=1, since otherwise it takes meaningless values
            }
            return(tml)
        }
        
        # Subfunction: dNdScv per gene
        selfun_cv = function(j) {
            y = as.numeric(genemuts[j,-1])
            x = RefCDS[[j]]
            exp_rel = y[5:8]/y[5]
            # Gamma
            shape = theta
            scale = y[9]/theta
            
            # a. Neutral model
            indneut = 1:4 # vector of neutral mutation types under this model (1=synonymous, 2=missense, 3=nonsense, 4=essential_splice)
            opt_t = mle_tcv(n_neutral=sum(y[indneut]), exp_rel_neutral=sum(exp_rel[indneut]), shape=shape, scale=scale)
            mrfold = max(1e-10, opt_t/y[5]) # Correction factor of "t" based on the obs/exp ratio of "neutral" mutations under the model
            ll0 = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,1,1,1),dim=c(4,numrates))), log=T)) + dgamma(opt_t, shape=shape, scale=scale, log=T) # loglik null model
            
            # b. Missense model: wmis==1, free wnon, free wspl
            indneut = 1:2
            opt_t = mle_tcv(n_neutral=sum(y[indneut]), exp_rel_neutral=sum(exp_rel[indneut]), shape=shape, scale=scale)
            mrfold = max(1e-10, opt_t/sum(y[5])) # Correction factor of "t" based on the obs/exp ratio of "neutral" mutations under the model
            wfree = y[3:4]/y[7:8]/mrfold; wfree[y[3:4]==0] = 0
            llmis = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,1,wfree),dim=c(4,numrates))), log=T)) + dgamma(opt_t, shape=shape, scale=scale, log=T) # loglik free wmis
            
            # c. Truncating muts model: free wmis, wnon==wspl==1
            indneut = c(1,3,4)
            opt_t = mle_tcv(n_neutral=sum(y[indneut]), exp_rel_neutral=sum(exp_rel[indneut]), shape=shape, scale=scale)
            mrfold = max(1e-10, opt_t/sum(y[5])) # Correction factor of "t" based on the obs/exp ratio of "neutral" mutations under the model
            wfree = y[2]/y[6]/mrfold; wfree[y[2]==0] = 0
            lltrunc = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,wfree,1,1),dim=c(4,numrates))), log=T)) + dgamma(opt_t, shape=shape, scale=scale, log=T) # loglik free wmis
            
            # d. Free selection model: free wmis, free wnon, free wspl
            indneut = 1
            opt_t = mle_tcv(n_neutral=sum(y[indneut]), exp_rel_neutral=sum(exp_rel[indneut]), shape=shape, scale=scale)
            mrfold = max(1e-10, opt_t/sum(y[5])) # Correction factor of "t" based on the obs/exp ratio of "neutral" mutations under the model
            wfree = y[2:4]/y[6:8]/mrfold; wfree[y[2:4]==0] = 0
            llall_unc = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,wfree),dim=c(4,numrates))), log=T)) + dgamma(opt_t, shape=shape, scale=scale, log=T) # loglik free wmis
          
            if (constrain_wnon_wspl == 0) {
            
                p = 1-pchisq(2*(llall_unc-c(llmis,lltrunc,ll0)),df=c(1,2,3))
                return(c(wfree,p))
                
            } else { # d2. Free selection model: free wmis, free wnon==wspl
            
                wmisfree = y[2]/y[6]/mrfold; wmisfree[y[2]==0] = 0
                wtruncfree = sum(y[3:4])/sum(y[7:8])/mrfold; wtruncfree[sum(y[3:4])==0] = 0
                llall = sum(dpois(x=x$N, lambda=x$L*mutrates*mrfold*t(array(c(1,wmisfree,wtruncfree,wtruncfree),dim=c(4,numrates))), log=T)) + dgamma(opt_t, shape=shape, scale=scale, log=T) # loglik free wmis, free wnon==wspl
                p = 1-pchisq(2*c(llall_unc-llmis,llall-c(lltrunc,ll0)),df=c(1,1,2))
                return(c(wmisfree,wtruncfree,wtruncfree,p))
            }
        }
        
        sel_cv = as.data.frame(t(sapply(1:nrow(genemuts), selfun_cv)))
        colnames(sel_cv) = c("wmis_cv","wnon_cv","wspl_cv","pmis_cv","ptrunc_cv","pallsubs_cv")
        sel_cv$qmis_cv = p.adjust(sel_cv$pmis_cv, method="BH")
        sel_cv$qtrunc_cv = p.adjust(sel_cv$ptrunc_cv, method="BH")
        sel_cv$qallsubs_cv = p.adjust(sel_cv$pallsubs_cv, method="BH")
        sel_cv = cbind(genemuts[,1:5],sel_cv)
        sel_cv = sel_cv[order(sel_cv$pallsubs_cv, sel_cv$pmis_cv, sel_cv$ptrunc_cv, -sel_cv$wmis_cv),] # Sorting genes in the output file
        
        ## Indel recurrence: based on a negative binomial regression (ideally fitted excluding major known driver genes)
        
        if (nrow(indels) >= min_indels) {
        
            geneindels = as.data.frame(array(0,dim=c(length(RefCDS),8)))
            colnames(geneindels) = c("gene_name","n_ind","n_induniq","n_indused","cds_length","excl","exp_unif","exp_indcv")
            geneindels$gene_name = sapply(RefCDS, function(x) x$gene_name)
            geneindels$n_ind = as.numeric(table(indels$gene)[geneindels[,1]]); geneindels[is.na(geneindels[,2]),2] = 0
            geneindels$n_induniq = as.numeric(table(unique(indels[,-1])$gene)[geneindels[,1]]); geneindels[is.na(geneindels[,3]),3] = 0
            geneindels$cds_length = sapply(RefCDS, function(x) x$CDS_length)
            
            if (use_indel_sites) {
                geneindels$n_indused = geneindels[,3]
            } else {
                geneindels$n_indused = geneindels[,2]
            }
            
            # Excluding known cancer genes (first using the input or the default list, but if this fails, we use a shorter data-driven list)
            geneindels$excl = (geneindels[,1] %in% known_cancergenes)
            min_bkg_genes = 50
            if (sum(!geneindels$excl)<min_bkg_genes | sum(geneindels[!geneindels$excl,"n_indused"]) == 0) { # If the exclusion list is too restrictive (e.g. targeted sequencing of cancer genes), then identify a shorter list of selected genes using the substitutions.
                newkc = as.vector(sel_cv$gene_name[sel_cv$qallsubs_cv<0.01])
                geneindels$excl = (geneindels[,1] %in% newkc)
                if (sum(!geneindels$excl)<min_bkg_genes | sum(geneindels[!geneindels$excl,"n_indused"]) == 0) { # If the new exclusion list is still too restrictive, then do not apply a restriction.
                    geneindels$excl = F
                    message("    No gene was excluded from the background indel model.")
                } else {
                    warning(sprintf("    Genes were excluded from the indel background model based on the substitution data: %s.", paste(newkc, collapse=", ")))
                }
            }
            
            geneindels$exp_unif = sum(geneindels[!geneindels$excl,"n_indused"]) / sum(geneindels[!geneindels$excl,"cds_length"]) * geneindels$cds_length
          
            # Negative binomial regression for indels
            
            if (is.null(cv)) {
                nbrdf = geneindels[,c("n_indused","exp_unif")][!geneindels[,6],] # We exclude known drivers from the fit
                model = MASS::glm.nb(n_indused ~ offset(log(exp_unif)) - 1 , data = nbrdf)
                nbrdf_all = geneindels[,c("n_indused","exp_unif")]
            } else {
                nbrdf = cbind(geneindels[,c("n_indused","exp_unif")], covs)[!geneindels[,6],] # We exclude known drivers from the fit
                if (sum(!geneindels$excl)<500) { # If there are <500 genes, we run the regression without covariates
                    model = MASS::glm.nb(n_indused ~ offset(log(exp_unif)) - 1 , data = nbrdf)
                } else {
                    model = tryCatch({
                        MASS::glm.nb(n_indused ~ offset(log(exp_unif)) + . , data = nbrdf) # We try running the model with covariates
                    }, warning = function(w){
                        MASS::glm.nb(n_indused ~ offset(log(exp_unif)) - 1 , data = nbrdf) # If there are warnings or errors we run the model without covariates
                    }, error = function(e){
                        MASS::glm.nb(n_indused ~ offset(log(exp_unif)) - 1 , data = nbrdf) # If there are warnings or errors we run the model without covariates
                    })
                }
                nbrdf_all = cbind(geneindels[,c("n_indused","exp_unif")], covs)
            }
            message(sprintf("    Regression model for indels (theta = %0.3g)", model$theta))
            
            theta_indels = model$theta
            nbregind = model
            geneindels$exp_indcv = exp(predict(model,nbrdf_all))
            geneindels$wind = geneindels$n_indused / geneindels$exp_indcv
        
            # Statistical testing for indel recurrence per gene
        
            geneindels$pind = pnbinom(q=geneindels$n_indused-1, mu=geneindels$exp_indcv, size=theta_indels, lower.tail=F)
            geneindels$qind = p.adjust(geneindels$pind, method="BH")
        
            # Fisher combined p-values (substitutions and indels)
            
            sel_cv = merge(sel_cv, geneindels, by="gene_name")[,c("gene_name","n_syn","n_mis","n_non","n_spl","n_indused","wmis_cv","wnon_cv","wspl_cv","wind","pmis_cv","ptrunc_cv","pallsubs_cv","pind","qmis_cv","qtrunc_cv","qallsubs_cv")]
            colnames(sel_cv) = c("gene_name","n_syn","n_mis","n_non","n_spl","n_ind","wmis_cv","wnon_cv","wspl_cv","wind_cv","pmis_cv","ptrunc_cv","pallsubs_cv","pind_cv","qmis_cv","qtrunc_cv","qallsubs_cv")
            sel_cv$pglobal_cv = 1 - pchisq(-2 * (log(sel_cv$pallsubs_cv) + log(sel_cv$pind_cv)), df = 4)
            sel_cv$qglobal_cv = p.adjust(sel_cv$pglobal, method="BH")
        
            sel_cv = sel_cv[order(sel_cv$pglobal_cv, sel_cv$pallsubs_cv, sel_cv$pmis_cv, sel_cv$ptrunc_cv, -sel_cv$wmis_cv),] # Sorting genes in the output file
        }
    }
    
    if (!any(!is.na(wrong_ref))) {
        wrong_refbase = NULL # Output value if there were no wrong bases
    }
    
    annot = annot[,setdiff(colnames(annot),c("start","end","geneind"))]
    
    if (outmats) {
        dndscvout = list(globaldnds = globaldnds, sel_cv = sel_cv, sel_loc = sel_loc, annotmuts = annot, genemuts = genemuts, mle_submodel = mle_submodel, exclsamples = exclsamples, exclmuts = exclmuts, nbreg = nbreg, nbregind = nbregind, poissmodel = poissmodel, wrongmuts = wrong_refbase, N = Nall, L = Lall)
    } else {
        dndscvout = list(globaldnds = globaldnds, sel_cv = sel_cv, sel_loc = sel_loc, annotmuts = annot, genemuts = genemuts, mle_submodel = mle_submodel, exclsamples = exclsamples, exclmuts = exclmuts, nbreg = nbreg, nbregind = nbregind, poissmodel = poissmodel, wrongmuts = wrong_refbase)
    }
    
} # EOF
```


```{r}

geneLists <- c("TNF", "TNFR2", "IL6","TGFb","IL17","TLR","NOD2","UPR","autophagy","epi_junc","PIP3_AKT", "cytokines_broad","colorectal_cancer","any_cancer","monogenic_ibd")
for(geneL in geneLists) {
  if(geneL %in% c("TNF", "TNFR2", "IL6","TGFb","IL17","TLR","NOD2","UPR","autophagy","epi_junc", "cytokines_broad","PIP3_AKT")) {
    ## The user can read in each gene list in Supplementary Table 12
    assign(paste(geneL, "_genes",sep=""), read.table(paste("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/", geneL, "_reactome.txt", sep="")))
  }
}

colorectal_cancer_genes <- read.table("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/colorectal_cancer_gene_list.txt")
monogenic_ibd_genes <- read.table("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/monogenic_IBD_epithelium_reactome_union.txt")
any_cancer_genes <- read.table("/Users/so11/phd/so11_nfs/somatic_ibd_p1/selection_analysis/geneLists/pan_cancer_analysis.txt")


for(geneL in geneLists) {
  assign(paste("dnds_",geneL,sep=""), dndscv_pvalspois(ibd_coding[, c(1:5)], get(paste(geneL, "_genes", sep=""))$V1,max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf))
  assign(paste("dnds_",geneL, "_UC",sep=""), dndscv_pvalspois(muts_UC, get(paste(geneL, "_genes", sep=""))$V1,max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf))
  assign(paste("dnds_",geneL, "_CD",sep=""), dndscv_pvalspois(muts_CD, get(paste(geneL, "_genes", sep=""))$V1,max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf))
  assign(paste("dnds_",geneL, "_ctrl",sep=""), dndscv_pvalspois(control_coding, get(paste(geneL, "_genes", sep=""))$V1,max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf))
}



df <- data.frame()
df_UC <- data.frame()
df_CD <- data.frame()
df_ctrl <- data.frame()
for(geneL in geneLists) {
  assign(paste("sel_cv_", geneL, sep=""), get(paste("dnds_",geneL,sep=""))$sel_cv)
  
  df_tmp <- data.frame(get(paste("dnds_",geneL,sep=""))$globaldnds)
  df_tmp$geneList <- geneL
  df <- rbind(df, df_tmp)
  
  df_tmp <- data.frame(get(paste("dnds_",geneL, "_UC",sep=""))$globaldnds)
  df_tmp$geneList <- geneL
  df_UC <- rbind(df_UC, df_tmp)
  
  df_tmp <- data.frame(get(paste("dnds_",geneL, "_CD",sep=""))$globaldnds)
  df_tmp$geneList <- geneL
  df_CD <- rbind(df_CD, df_tmp)
  
  df_tmp <- data.frame(get(paste("dnds_",geneL, "_ctrl",sep=""))$globaldnds)
  df_tmp$geneList <- geneL
  df_ctrl <- rbind(df_ctrl, df_tmp)
}
mis_and_trunc <- df[df$name %in% c("wmis", "wtru"),]
mis_and_trunc_UC <- df_UC[df_UC$name %in% c("wmis", "wtru"),]
mis_and_trunc_CD <- df_CD[df_CD$name %in% c("wmis", "wtru"),]
mis_and_trunc_ctrl <- df_ctrl[df_ctrl$name %in% c("wmis", "wtru"),]
```

I intend to show the dNdS ratios broken down by disease sub-type in a supplementary figure. However, that is purely to convince the reader that the effects are not obviously different between UC and CD cases. Let it be made clear here that the multiple testing correction will only extend to the combined IBD set so q-values will not be reported for the other diseases. 


```{r}

P_mis <- as.numeric()
P_trunc <- as.numeric()
P_mis_UC <- as.numeric()
P_trunc_UC <- as.numeric()
P_mis_CD <- as.numeric()
P_trunc_CD <- as.numeric()
P_mis_ctrl <- as.numeric()
P_trunc_ctrl <- as.numeric()
for(geneL in geneLists) {
  P_mis <- c(P_mis, summary(get(paste("dnds_", geneL, sep=""))$poissmodel)$coefficients[c("wmis"),4] )
  P_trunc <- c(P_trunc, summary(get(paste("dnds_", geneL, sep=""))$poissmodel)$coefficients[c("wtru"),4] )
  
  P_mis_UC <- c(P_mis_UC, summary(get(paste("dnds_", geneL, "_UC", sep=""))$poissmodel)$coefficients[c("wmis"),4] )
  P_trunc_UC <- c(P_trunc_UC, summary(get(paste("dnds_", geneL, "_UC", sep=""))$poissmodel)$coefficients[c("wtru"),4] )
  
  P_mis_CD <- c(P_mis_CD, summary(get(paste("dnds_", geneL, "_CD", sep=""))$poissmodel)$coefficients[c("wmis"),4] )
  P_trunc_CD <- c(P_trunc_CD, summary(get(paste("dnds_", geneL, "_CD", sep=""))$poissmodel)$coefficients[c("wtru"),4] )
  
  P_mis_ctrl <- c(P_mis_ctrl, summary(get(paste("dnds_", geneL, "_ctrl", sep=""))$poissmodel)$coefficients[c("wmis"),4] )
  P_trunc_ctrl <- c(P_trunc_ctrl, summary(get(paste("dnds_", geneL, "_ctrl", sep=""))$poissmodel)$coefficients[c("wtru"),4] )
}

mis_and_trunc$p_pois <- NA
mis_and_trunc$p_pois[seq(from=1, to=nrow(mis_and_trunc), by=2)] <- P_mis
mis_and_trunc$p_pois[seq(from=2, to=nrow(mis_and_trunc), by=2)] <- P_trunc
mis_and_trunc$q_BHcorr <- p.adjust(mis_and_trunc$p_pois, method="BH")

mis_and_trunc_UC$p_pois <- NA
mis_and_trunc_UC$p_pois[seq(from=1, to=nrow(mis_and_trunc_UC), by=2)] <- P_mis_UC
mis_and_trunc_UC$p_pois[seq(from=2, to=nrow(mis_and_trunc_UC), by=2)] <- P_trunc_UC
mis_and_trunc_UC$q_BHcorr <- NA

mis_and_trunc_CD$p_pois <- NA
mis_and_trunc_CD$p_pois[seq(from=1, to=nrow(mis_and_trunc_CD), by=2)] <- P_mis_CD
mis_and_trunc_CD$p_pois[seq(from=2, to=nrow(mis_and_trunc_CD), by=2)] <- P_trunc_CD
mis_and_trunc_CD$q_BHcorr <- NA

mis_and_trunc_ctrl$p_pois <- NA
mis_and_trunc_ctrl$p_pois[seq(from=1, to=nrow(mis_and_trunc_ctrl), by=2)] <- P_mis_ctrl
mis_and_trunc_ctrl$p_pois[seq(from=2, to=nrow(mis_and_trunc_ctrl), by=2)] <- P_trunc_ctrl
mis_and_trunc_ctrl$q_BHcorr <- NA

mis_and_trunc$Disease <- "IBD combined"
mis_and_trunc_CD$Disease <- "CD"
mis_and_trunc_UC$Disease <- "UC"
mis_and_trunc_ctrl$Disease <- "Controls"

mis_and_trunc <- rbind(mis_and_trunc, mis_and_trunc_CD, mis_and_trunc_UC, mis_and_trunc_ctrl)
mis_and_trunc$Disease <- factor(mis_and_trunc$Disease, levels=c("IBD combined", "CD", "UC", "Controls"))

write.table(mis_and_trunc, "/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table13_pathway_dNdS.txt", row.names = F, quote = F)
```


The TLR and IL-17 pathways substantially overlap. Want to see if the TLR signal is significant if I remove the genes overlapping the IL17 pathway. It turns out that the TLR enrichment is driven by genes in both pathways. 

```{r}
TLR_wo_IL17 <- TLR_genes$V1[!(TLR_genes$V1 %in% IL17_genes$V1)]

dnds_TLR_wo_IL17 <- dndscv_pvalspois(muts, TLR_wo_IL17,max_muts_per_gene_per_sample = Inf, max_coding_muts_per_sample = Inf)
dnds_TLR_wo_IL17$globaldnds

summary(dnds_TLR_wo_IL17$poissmodel)$coefficients[c("wmis"),4] 
summary(dnds_TLR_wo_IL17$poissmodel)$coefficients[c("wtru"),4] 
```




## Restricted hypothesis testing

Perform restricted hypothesis testing on the genes discovered in Nanki et al and Kakiuchi et al. 

```{r}
prior_genes <- c("NFKBIZ", "TRAF3IP2", "NOS2", "IL17RA", "HNRNPF", "ARID1B", "BCORL1", "BCOR","ETV6",
                 "RNF43", "TP53", "KRAS","IL17RC")

sel_cv_rht <- sel_cv[sel_cv$gene_name %in% prior_genes, ]
sel_cv_rht$qrht <- p.adjust(sel_cv_rht$pglobal_cv, method = "BH")

sel_cv[sel_cv$gene_name %in% prior_genes, ]

write.table(sel_cv[sel_cv$gene_name %in% prior_genes, ], "/Users/so11/phd/somatic_ibd_p1/manuscript/Cell_submission/Supplementary_material/Supplementary_Table15_rht.txt", quote = F, row.names = F)
```





